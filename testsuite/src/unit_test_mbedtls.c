/*
 *  CUnit - A Unit testing framework library for C.
 *  Copyright (C) 2001        Anil Kumar
 *  Copyright (C) 2004, 2005  Anil Kumar, Jerry St.Clair
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Library General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "CUnit.h"
#include "mbedtls_cmac_exa.h"
#include "unit_test_mbedtls.h"
#include "mbedtls_hmac.h"

/* WARNING - MAINTENANCE NIGHTMARE AHEAD
 *
 * If you change any of the tests & suites below, you also need
 * to keep track of changes in the result statistics and reflect
 * any changes in the result report counts in print_example_results().
 *
 * Yes, this could have been designed better using a more
 * automated mechanism.  No, it was not done that way.
 */

/* Suite initialization/cleanup functions */
static int suite_success_init(void) {
    printf("suite_succuse_init\n");
    return 0; }
static int suite_success_clean(void) { return 0; }

static int suite_failure_init(void) { return 1;}
static int suite_failure_clean(void) { return 1; }

static void testSuccess1(void) { CU_ASSERT(1); }
static void testSuccess2(void) { CU_ASSERT(2); }
static void testSuccess3(void) { CU_ASSERT(3); }

static void testSuiteFailure1(void) { CU_ASSERT(0); }
static void testSuiteFailure2(void) { CU_ASSERT(2); }

static void testFailure1(void) { CU_ASSERT(0); }
static void testFailure2(void) { CU_ASSERT(0); }
static void testFailure3(void) { CU_ASSERT(0); }

#define TEST_FUN(a)  ((void*)a)

static uint8_t cmac_gd_msg[] = {
        0x6a, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
        0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
        0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
        0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
        0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
        0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,
};
static uint8_t cmac_aes_128_ecb_gd_key[] = {
        0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c,
};
static uint8_t cmac_aes_128_ecb_gd_output[] = {
        0x51, 0xf0, 0xbe, 0xbf, 0x7e, 0x3b, 0x9d, 0x92,
        0xfc, 0x49, 0x74, 0x17, 0x79, 0x36, 0x3c, 0xfe,
};
static uint8_t cmac_aes_192_ecb_gd_key[] = {
        0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c,
        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c,
};
static uint8_t cmac_aes_192_ecb_gd_output[] = {
        0x51, 0xf0, 0xbe, 0xbf, 0x7e, 0x3b, 0x9d, 0x92,
        0xfc, 0x49, 0x74, 0x17, 0x79, 0x36, 0x3c, 0xfe,
        0xfc, 0x49, 0x74, 0x17, 0x79, 0x36, 0x3c, 0xfe,
};
#if 0
static void test_mbedtls_cmac_aes_128_ecb(void)
{
    int ret = 0;
    uint8_t output[16];
    size_t outlen = 0;
    memset(output, 0, ARRAY_SIZE(output));
    ret = mbedtls_cmac_aes_128_ecb(cmac_aes_128_ecb_gd_key, 128/8,
                                   cmac_gd_msg, ARRAY_SIZE(cmac_gd_msg),
                                   output, &outlen);
    CU_ASSERT_EQUAL(ret, 0);
    CU_ASSERT_STRING_EQUAL(output, cmac_aes_128_ecb_gd_output);
    PRINTF_ARRAY(output, ARRAY_SIZE(output), "\ncacu output :");
    PRINTF_ARRAY(cmac_aes_128_ecb_gd_output, ARRAY_SIZE(cmac_aes_128_ecb_gd_output), "gldn output :");
}

static void test_mbedtls_cmac_aes_192_ecb(void)
{
    int ret = 0;
    uint8_t output[24];
    size_t outlen = 0;
    memset(output, 0, ARRAY_SIZE(output));
    ret = mbedtls_cmac_aes_192_ecb(cmac_aes_192_ecb_gd_key, 192/8,
                                   cmac_gd_msg, ARRAY_SIZE(cmac_gd_msg),
                                   output, &outlen);
    CU_ASSERT_EQUAL(ret, 0);
    CU_ASSERT_STRING_EQUAL(output, cmac_aes_192_ecb_gd_output);
    PRINTF_ARRAY(output, ARRAY_SIZE(output), "\noutput :");
    PRINTF_ARRAY(cmac_aes_128_ecb_gd_output, ARRAY_SIZE(cmac_aes_128_ecb_gd_output), "\noutput :");
}

static CU_TestInfo test_cmac_suite[] = {
        {"test mbedtls cmac_aes_128_ecb", TEST_FUN(test_mbedtls_cmac_aes_128_ecb)},
        {"test mbedtls cmac_aes_192_ecb", TEST_FUN(test_mbedtls_cmac_aes_192_ecb)},
        CU_TEST_INFO_NULL
};
#endif

static const unsigned char aes_test_ecb_enc[16] =
{
        0xC3, 0x4C, 0x05, 0x2C, 0xC0, 0xDA, 0x8D, 0x73,
        0x45, 0x1A, 0xFE, 0x5F, 0x03, 0xBE, 0x29, 0x7F
};

static const unsigned char aes_test_ecb_key[16] =
{
        0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
        0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C
};
static const unsigned char aes_test_ecb_dec[16] = {
        0x55, 0x5c, 0x82, 0x24, 0xe2, 0xc9, 0x58, 0x73,
        0x12, 0x08, 0x5b, 0xfb, 0x4e, 0xcb, 0x04, 0xb8
};
static void test_mbedtls_aes_ecb_enc(void)
{
    mbedtls_aes_context aes_ctx;
    unsigned char dec_plain[16] = {0};
    unsigned char i = 0;
    int ret = 0;
    mbedtls_aes_init(&aes_ctx);
    mbedtls_aes_setkey_enc(&aes_ctx, aes_test_ecb_key, 128);
    mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_ENCRYPT, aes_test_ecb_enc, dec_plain);
    mbedtls_aes_free(&aes_ctx);
#if 0
    for (i = 0; i < 16; i ++) {
        printf("0x%2x,", dec_plain[i]);
    }
    printf("            ");
#endif
    ret = memcmp(aes_test_ecb_dec, dec_plain, sizeof aes_test_ecb_enc);
    CU_ASSERT_NSTRING_EQUAL(aes_test_ecb_dec, dec_plain, sizeof aes_test_ecb_enc)
}

static void test_mbedtls_aes_ecb_dec(void)
{
    mbedtls_aes_context aes_ctx;
    unsigned char enc_plain[16] = {0};
    unsigned char i = 0;
    int ret = 0;
    mbedtls_aes_init(&aes_ctx);
    mbedtls_aes_setkey_dec(&aes_ctx, aes_test_ecb_key, 128);
    mbedtls_aes_crypt_ecb(&aes_ctx, MBEDTLS_AES_DECRYPT, aes_test_ecb_dec, enc_plain);
    mbedtls_aes_free(&aes_ctx);
#if 0
    for (i = 0; i < 16; i ++) {
        printf("0x%2x,", enc_plain[i]);
    }
    printf("            ");
#endif
    ret = memcmp(enc_plain, aes_test_ecb_dec, sizeof aes_test_ecb_dec);
    CU_ASSERT_NSTRING_EQUAL(aes_test_ecb_enc, enc_plain, sizeof aes_test_ecb_dec)
}

static const unsigned char aes_test_cbc_enc[256] = {
        0x13,0x9e,0x26,0xaf,0xc5,0x72,0x44,0xbc,0x6d,0x78,0x50,0x66,0x2f,0x66,0x8f,0x8e,
        0x4f,0xa0,0x34,0x03,0x7c,0x72,0x20,0x46,0x12,0xbd,0x7b,0x74,0xbe,0xf7,0x38,0x11,
        0x9d,0xe6,0x03,0x8b,0x4f,0xcc,0x42,0x16,0xa7,0xd0,0x8d,0x9b,0x7d,0x9e,0x10,0x36,
        0x9d,0x38,0x35,0x76,0x31,0xa3,0x23,0x54,0x74,0x1e,0xc1,0x16,0xd3,0x18,0x59,0xfb,
        0xdf,0x2a,0x7b,0xe4,0x2b,0x0d,0xd3,0xa0,0xb2,0x0f,0x9a,0xe9,0x7e,0xc8,0x0e,0x1e,
        0x13,0xea,0x6a,0x20,0xb9,0x0f,0x68,0x06,0xe4,0xb7,0xad,0x7d,0xca,0xb1,0x83,0x10,
        0xa2,0x9e,0x9f,0xd8,0x39,0x47,0x8f,0x7a,0x8f,0x70,0x57,0xbd,0x90,0xef,0xec,0x5f,
        0xb4,0x1e,0x62,0xe8,0xd6,0x35,0xc5,0x87,0x52,0x27,0x94,0xcd,0xe4,0x53,0xeb,0xb5,
        0xa2,0xd9,0x28,0x61,0x34,0x43,0xab,0x5a,0xd9,0xc9,0x38,0x50,0xba,0x35,0x0c,0x4c,
        0x8c,0xd7,0xc7,0xaa,0x79,0x2f,0x0d,0x00,0x27,0x90,0x08,0x04,0x50,0xbe,0xd8,0x7b,
        0x92,0x08,0x9b,0xb7,0x6d,0xe1,0xc2,0x2e,0x13,0xce,0xbd,0xa3,0xd5,0x22,0x46,0xb9,
        0x27,0xee,0x57,0x28,0xe8,0x7a,0x27,0x2f,0x3c,0x2e,0xbe,0xd0,0xfa,0xd1,0xad,0x91,
        0xb4,0xb4,0x2c,0x43,0xce,0x45,0xc0,0xdb,0x73,0x44,0x65,0x57,0xb4,0x4c,0xda,0x4a,
        0xbb,0xc6,0x25,0x8c,0x5f,0x7a,0x24,0xd5,0xac,0xc4,0xc3,0x0a,0xcb,0x7d,0x7e,0x48,
        0x04,0x40,0xba,0x33,0x79,0xca,0x50,0x1d,0x4f,0xf5,0xbd,0x8e,0x4b,0xee,0xef,0xe6,
        0xcd,0x00,0xe7,0x3f,0xd9,0x65,0xd0,0xcc,0x60,0x27,0x80,0x7b,0xe3,0x7e,0x07,0x85
};

static const unsigned char aes_test_cbc_key[16] =
        {
                0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
                0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C,
        };
static const unsigned char aes_test_cbc_key_256[32] =
        {
                0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
                0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C,
                0x1f, 0x72, 0x86, 0x98, 0x4d, 0xde, 0x8c, 0xef,
                0xfb, 0xd8, 0x54, 0x3c, 0x7b, 0x6c, 0xa5, 0x74,
        };
static const unsigned char aes_test_cbc_iv[16] = {
        0x55, 0x5c, 0x82, 0x24, 0xe2, 0xc9, 0x58, 0x73,
        0x12, 0x08, 0x5b, 0xfb, 0x4e, 0xcb, 0x04, 0xb8,
};

static const unsigned char aes_test_cbc_dec[256] = {
        0xb0,0x6a,0x73,0x0c,0x8d,0x5a,0x62,0x73,0x91,0x86,0x65,0x0c,0x96,0xfe,0x67,0x34,
        0x50,0x5f,0x0c,0x11,0x4d,0xe7,0xf0,0xdb,0x0d,0xed,0xbd,0xb6,0xd5,0x90,0xf5,0x93,
        0xe1,0xfb,0x76,0x7e,0xc3,0xdf,0x45,0xa0,0x8c,0x18,0xcf,0xee,0x77,0x9d,0xbe,0x72,
        0xdc,0xe8,0xc8,0x4b,0xb3,0x3a,0xec,0xf3,0x4e,0xdc,0xd6,0xc8,0x63,0x11,0xfd,0xd4,
        0x69,0xbc,0x8c,0xfe,0xf4,0x9b,0xad,0x45,0x4d,0x3e,0x63,0x49,0xce,0xe7,0x81,0x7a,
        0x62,0x58,0xcf,0xc7,0x74,0xc2,0x41,0x12,0x61,0x7b,0xb7,0x22,0xd8,0x15,0x1d,0x70,
        0x9f,0x06,0x5c,0x79,0x07,0x38,0xdb,0x16,0xef,0x70,0x3e,0x59,0x7c,0x09,0x40,0x74,
        0x46,0x63,0x8c,0x58,0xe2,0x57,0xff,0x67,0x55,0x56,0x87,0x1a,0x56,0x22,0x5a,0x2f,
        0xb8,0x16,0x91,0xf3,0x04,0x9e,0x47,0xb7,0xef,0x71,0x39,0xd8,0x30,0xec,0x62,0xaa,
        0x0b,0xeb,0x7e,0xba,0xd0,0x76,0x2a,0x6e,0xed,0xa8,0x7f,0x87,0x16,0xa2,0xda,0x9f,
        0xb4,0x70,0xdc,0xa4,0x1f,0xc5,0x20,0x47,0x5f,0x41,0xf0,0x3e,0x6a,0xdc,0xc4,0x75,
        0xcf,0x11,0x88,0x78,0x98,0x3b,0x4e,0x5e,0xc0,0x25,0x0e,0xe6,0xfc,0xeb,0x0a,0xaa,
        0x22,0x9c,0x39,0xca,0x16,0x80,0x38,0x6a,0xcc,0x91,0x81,0x50,0x16,0x99,0x94,0x0d,
        0x32,0x56,0x6b,0x92,0x92,0x5e,0x52,0xb8,0x6e,0x4b,0x79,0x3f,0x79,0x87,0x21,0xdd,
        0x4e,0xa9,0xf2,0x84,0x7a,0xe9,0xf4,0x3d,0x4e,0xc7,0x46,0x6d,0x3d,0x3c,0x88,0x4e,
        0xa0,0x7d,0xda,0xd8,0x06,0x1a,0x35,0xa5,0x42,0x50,0x5a,0xdf,0x5d,0x43,0x36,0x3e,
};
static const unsigned char aes_test_cbc_dec_256[256] = {
        0xec,0x85,0x23,0x01,0xd0,0x24,0x5c,0x0e,0x42,0x84,0xd3,0x8e,0x03,0x32,0xa3,0x45,
        0x24,0x33,0xe1,0x50,0x77,0x72,0x3b,0x38,0xb3,0xc8,0x16,0x23,0x57,0xc5,0xf4,0x1a,
        0x78,0x21,0xf7,0xcd,0xad,0x77,0x43,0x4d,0x13,0x50,0xa4,0x4c,0xee,0x77,0x30,0x6c,
        0x67,0x90,0x57,0x64,0x79,0xf5,0x56,0x48,0xb2,0x7c,0x40,0x29,0x2a,0x44,0x5f,0xb8,
        0x1b,0x20,0x60,0x87,0x8e,0xae,0xd0,0x7e,0x2f,0x5f,0x08,0xcb,0xe8,0xff,0xa4,0x52,
        0xb9,0xa1,0x11,0x11,0x8a,0x2b,0xbc,0xdd,0x42,0xa2,0xde,0xa0,0xd5,0x0e,0x1f,0xba,
        0xa4,0xe6,0x97,0x71,0x6c,0x5b,0x97,0xe7,0x91,0x1a,0xfe,0x04,0x6c,0x2e,0x08,0xb0,
        0x3b,0x90,0x03,0x4f,0x86,0x58,0xd7,0xd1,0xd1,0x5e,0xbe,0xef,0xc0,0x9a,0x54,0x5e,
        0xef,0x0f,0x6a,0x2d,0xac,0x4a,0x39,0xc7,0xdb,0xce,0x54,0xe4,0x35,0xaf,0xc9,0xeb,
        0x70,0x2d,0x30,0xa2,0x03,0xc3,0xc3,0x56,0xa9,0xda,0x46,0x7a,0xad,0x27,0x09,0xf9,
        0x24,0xc2,0x41,0xdb,0x9e,0xd1,0x5d,0x84,0x90,0xe3,0x09,0xdc,0x6d,0xa3,0xfd,0x65,
        0xcb,0xb2,0x93,0x28,0x91,0x5c,0x01,0xa4,0x04,0xa3,0xfd,0x55,0x7c,0x83,0x07,0x6f,
        0x3f,0xc9,0x3d,0xe4,0xc4,0x6a,0xca,0x5a,0xd8,0x62,0xd7,0x23,0x84,0xcb,0xae,0x4d,
        0xb9,0x17,0x76,0x73,0xfa,0x9e,0xc8,0x50,0xd3,0x3e,0x50,0xcd,0xdf,0x98,0x04,0x30,
        0x0a,0x3e,0xc7,0x66,0x8e,0x2f,0x63,0xe8,0x4b,0xb3,0x8c,0x10,0x1e,0x4a,0xba,0xd4,
        0x78,0xfd,0xa8,0x6f,0xb8,0x70,0xa8,0x90,0x7a,0x99,0x53,0x86,0xdd,0x7e,0xc8,0x37,
};

static void test_mbedtls_aes_cbc_enc(void)
{
    mbedtls_aes_context aes_ctx;
    unsigned char dec_plain[256] = {0};
    unsigned int i = 0;
    int ret = 0;
    uint8_t iv[16] = {0};

    mbedtls_aes_init(&aes_ctx);
    mbedtls_aes_setkey_enc(&aes_ctx, aes_test_ecb_key, 128);
    memcpy(iv, aes_test_cbc_iv, sizeof iv);
    mbedtls_aes_crypt_cbc(&aes_ctx,
                          MBEDTLS_AES_ENCRYPT,
                          sizeof(aes_test_cbc_enc),
                          iv,
                          aes_test_cbc_enc,
                          dec_plain);
    mbedtls_aes_free(&aes_ctx);
#if 0
    for (i = 0; i < sizeof(dec_plain); i ++) {
        if (i % 16 == 0) {
            printf("\n");
        }
        printf("0x%02x,", dec_plain[i]);
    }
    printf("            ");
#endif
    ret = memcmp(aes_test_cbc_enc, dec_plain, sizeof aes_test_ecb_enc);
    CU_ASSERT_NSTRING_EQUAL(aes_test_cbc_dec, dec_plain, sizeof aes_test_cbc_dec)
}

static void test_mbedtls_aes_cbc_dec(void)
{
    mbedtls_aes_context aes_ctx;
    unsigned char enc_plain[256] = {0};
    unsigned int i = 0;
    int ret = 0;
    uint8_t iv[16] = {0};

    mbedtls_aes_init(&aes_ctx);
    mbedtls_aes_setkey_dec(&aes_ctx, aes_test_cbc_key, 128);
    memcpy(iv, aes_test_cbc_iv, sizeof iv);
    mbedtls_aes_crypt_cbc(&aes_ctx,
                          MBEDTLS_AES_DECRYPT,
                          sizeof(aes_test_cbc_dec),
                          iv,
                          aes_test_cbc_dec,
                          enc_plain);
    mbedtls_aes_free(&aes_ctx);
#if 0
    for (i = 0; i < sizeof(enc_plain); i ++) {
        if (i % 16 == 0) {
            printf("\n");
        }
        printf("0x%2x,", dec_plain[i]);
    }
    printf("            ");
#endif
    ret = memcmp(aes_test_cbc_enc, enc_plain, sizeof aes_test_ecb_enc);
    CU_ASSERT_NSTRING_EQUAL(aes_test_cbc_enc, enc_plain, sizeof aes_test_cbc_enc)
}

static void test_mbedtls_aes_cbc_enc_256(void)
{
    mbedtls_aes_context aes_ctx;
    unsigned char dec_plain[256] = {0};
    unsigned int i = 0;
    int ret = 0;
    uint8_t iv[16] = {0};

    mbedtls_aes_init(&aes_ctx);
    mbedtls_aes_setkey_enc(&aes_ctx, aes_test_cbc_key_256, 256);
    memcpy(iv, aes_test_cbc_iv, sizeof iv);
    mbedtls_aes_crypt_cbc(&aes_ctx,
                          MBEDTLS_AES_ENCRYPT,
                          sizeof(aes_test_cbc_enc),
                          iv,
                          aes_test_cbc_enc,
                          dec_plain);
    mbedtls_aes_free(&aes_ctx);
#if 1
    for (i = 0; i < sizeof(dec_plain); i ++) {
        if (i % 16 == 0) {
            printf("\n");
        }
        printf("0x%02x,", dec_plain[i]);
    }
    printf("            ");
#endif
    ret = memcmp(aes_test_cbc_dec_256, dec_plain, sizeof aes_test_cbc_dec_256);
    CU_ASSERT_NSTRING_EQUAL(aes_test_cbc_dec_256, dec_plain, sizeof aes_test_cbc_dec_256)
}

static void test_mbedtls_aes_cbc_dec_256(void)
{
    mbedtls_aes_context aes_ctx;
    unsigned char enc_plain[256] = {0};
    unsigned char dec_plain[256] = {0};
    unsigned int i = 0;
    int ret = 0;
    uint8_t iv[16] = {0};

    mbedtls_aes_init(&aes_ctx);
    mbedtls_aes_setkey_dec(&aes_ctx, aes_test_cbc_key_256, 256);
    memcpy(iv, aes_test_cbc_iv, sizeof iv);
    mbedtls_aes_crypt_cbc(&aes_ctx,
                          MBEDTLS_AES_DECRYPT,
                          sizeof(aes_test_cbc_dec_256),
                          iv,
                          aes_test_cbc_dec_256,
                          enc_plain);
    mbedtls_aes_free(&aes_ctx);
#if 1
    for (i = 0; i < sizeof(enc_plain); i ++) {
        if (i % 16 == 0) {
            printf("\n");
        }
        printf("0x%02x,", enc_plain[i]);
    }
    printf("            ");
#endif
    ret = memcmp(aes_test_cbc_enc, enc_plain, sizeof enc_plain);
    CU_ASSERT_NSTRING_EQUAL(aes_test_cbc_enc, enc_plain, sizeof enc_plain)
}

static const unsigned char aes_test_ctr_enc[512] = {
        0x13,0x9e,0x26,0xaf,0xc5,0x72,0x44,0xbc,0x6d,0x78,0x50,0x66,0x2f,0x66,0x8f,0x8e,
        0x4f,0xa0,0x34,0x03,0x7c,0x72,0x20,0x46,0x12,0xbd,0x7b,0x74,0xbe,0xf7,0x38,0x11,
        0x9d,0xe6,0x03,0x8b,0x4f,0xcc,0x42,0x16,0xa7,0xd0,0x8d,0x9b,0x7d,0x9e,0x10,0x36,
        0x9d,0x38,0x35,0x76,0x31,0xa3,0x23,0x54,0x74,0x1e,0xc1,0x16,0xd3,0x18,0x59,0xfb,
        0xdf,0x2a,0x7b,0xe4,0x2b,0x0d,0xd3,0xa0,0xb2,0x0f,0x9a,0xe9,0x7e,0xc8,0x0e,0x1e,
        0x13,0xea,0x6a,0x20,0xb9,0x0f,0x68,0x06,0xe4,0xb7,0xad,0x7d,0xca,0xb1,0x83,0x10,
        0xa2,0x9e,0x9f,0xd8,0x39,0x47,0x8f,0x7a,0x8f,0x70,0x57,0xbd,0x90,0xef,0xec,0x5f,
        0xb4,0x1e,0x62,0xe8,0xd6,0x35,0xc5,0x87,0x52,0x27,0x94,0xcd,0xe4,0x53,0xeb,0xb5,
        0xa2,0xd9,0x28,0x61,0x34,0x43,0xab,0x5a,0xd9,0xc9,0x38,0x50,0xba,0x35,0x0c,0x4c,
        0x8c,0xd7,0xc7,0xaa,0x79,0x2f,0x0d,0x00,0x27,0x90,0x08,0x04,0x50,0xbe,0xd8,0x7b,
        0x92,0x08,0x9b,0xb7,0x6d,0xe1,0xc2,0x2e,0x13,0xce,0xbd,0xa3,0xd5,0x22,0x46,0xb9,
        0x27,0xee,0x57,0x28,0xe8,0x7a,0x27,0x2f,0x3c,0x2e,0xbe,0xd0,0xfa,0xd1,0xad,0x91,
        0xb4,0xb4,0x2c,0x43,0xce,0x45,0xc0,0xdb,0x73,0x44,0x65,0x57,0xb4,0x4c,0xda,0x4a,
        0xbb,0xc6,0x25,0x8c,0x5f,0x7a,0x24,0xd5,0xac,0xc4,0xc3,0x0a,0xcb,0x7d,0x7e,0x48,
        0x04,0x40,0xba,0x33,0x79,0xca,0x50,0x1d,0x4f,0xf5,0xbd,0x8e,0x4b,0xee,0xef,0xe6,
        0xcd,0x00,0xe7,0x3f,0xd9,0x65,0xd0,0xcc,0x60,0x27,0x80,0x7b,0xe3,0x7e,0x07,0x85,
        0x13,0x9e,0x26,0xaf,0xc5,0x72,0x44,0xbc,0x6d,0x78,0x50,0x66,0x2f,0x66,0x8f,0x8e,
        0x4f,0xa0,0x34,0x30,0x7c,0x72,0x20,0x46,0x12,0xbd,0x7b,0x74,0xbe,0xf7,0x38,0x11,
        0x9d,0xe6,0x30,0x8b,0x4f,0xcc,0x42,0x16,0xa7,0xd0,0x8d,0x9b,0x7d,0x9e,0x10,0x36,
        0x9d,0x38,0x35,0x76,0x31,0xa3,0x23,0x54,0x74,0x1e,0xc1,0x16,0xd3,0x18,0x59,0xfb,
        0xdf,0x2a,0x7b,0xe4,0x2b,0x0d,0xd3,0xa0,0xb2,0x0f,0x9a,0xe9,0x7e,0xc8,0x0e,0x1e,
        0x13,0xea,0x6a,0x20,0xb9,0x0f,0x68,0x06,0xe4,0xb7,0xad,0x7d,0xca,0xb1,0x83,0x10,
        0xa2,0x9e,0x9f,0xd8,0x39,0x47,0x8f,0x7a,0x8f,0x70,0x57,0xbd,0x90,0xef,0xec,0x5f,
        0xb4,0x1e,0x62,0xe8,0xd6,0x35,0xc5,0x87,0x52,0x27,0x94,0xcd,0xe4,0x53,0xeb,0xb5,
        0xa2,0xd9,0x28,0x61,0x34,0x43,0xab,0x5a,0xd9,0xc9,0x38,0x50,0xba,0x35,0x0c,0x4c,
        0x8c,0xd7,0xc7,0xaa,0x79,0x2f,0x0d,0x00,0x27,0x90,0x08,0x04,0x50,0xbe,0xd8,0x7b,
        0x92,0x08,0x9b,0xb7,0x6d,0xe1,0xc2,0x2e,0x13,0xce,0xbd,0xa3,0xd5,0x22,0x46,0xb9,
        0x27,0xee,0x57,0x28,0xe8,0x7a,0x27,0x2f,0x3c,0x2e,0xbe,0xd0,0xfa,0xd1,0xad,0x91,
        0xb4,0xb4,0x2c,0x43,0xce,0x45,0xc0,0xdb,0x73,0x44,0x65,0x57,0xb4,0x4c,0xda,0x4a,
        0xbb,0xc6,0x25,0x8c,0x5f,0x7a,0x24,0xd5,0xac,0xc4,0xc3,0x0a,0xcb,0x7d,0x7e,0x48,
        0x40,0x40,0xba,0x33,0x79,0xca,0x50,0x1d,0x4f,0xf5,0xbd,0x8e,0x4b,0xee,0xef,0xe6,
        0xcd,0x00,0xe7,0x3f,0xd9,0x65,0xd0,0xcc,0x60,0x27,0x80,0x7b,0xe3,0x7e,0x46,0x89
};

static const unsigned char aes_test_ctr_key[16] = {
        0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
        0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C,
        };
static const unsigned char aes_test_ctr_iv[16] = {
        0x55, 0x5c, 0x82, 0x24, 0xe2, 0xc9, 0x58, 0x73,
        0x12, 0x08, 0x5b, 0xfb, 0x4e, 0xcb, 0x04, 0xb8,
};

static const unsigned char aes_test_ctr_dec[512] = {
        0x98,0xf6,0xc2,0xbf,0x15,0xd6,0x79,0x39,0xd3,0x14,0x18,0xf9,0xf3,0x7c,0x15,0x67,
        0x28,0x19,0xa0,0x66,0x89,0xc1,0xe3,0xc5,0x5b,0x0b,0x15,0xc8,0x04,0xc1,0x61,0x19,
        0x27,0x29,0xd8,0xe4,0xd6,0x4e,0xe1,0x5c,0x2d,0x76,0xb8,0x04,0x6c,0x46,0x94,0xdd,
        0xba,0x8d,0x3b,0xe6,0x8d,0xbb,0xbb,0x15,0xbf,0xa9,0xf0,0x79,0x66,0xd1,0x0e,0x43,
        0xa3,0x50,0x43,0x8f,0xb2,0x5b,0x08,0x2a,0x51,0x6d,0x27,0x16,0x94,0x2c,0x68,0x57,
        0x0b,0x3c,0x8f,0xce,0x68,0x97,0x60,0x3d,0x06,0xa2,0x65,0xcb,0xee,0xf5,0x84,0xb1,
        0x68,0x95,0x22,0x27,0xf4,0xb0,0x87,0x44,0x25,0x4f,0x76,0x65,0xb4,0x5b,0x6f,0xb9,
        0xe8,0x59,0xec,0xa0,0x4d,0xc4,0x5c,0xa5,0x36,0x00,0xa4,0x05,0xef,0x3b,0x38,0xd8,
        0xf7,0xc2,0xc9,0xfa,0xc9,0x1e,0xc4,0xd0,0xbc,0x36,0x42,0x59,0x4a,0x19,0x7e,0x7e,
        0x42,0x34,0x28,0xaa,0xdf,0x4b,0x0c,0xe9,0xc0,0x9b,0x54,0xb6,0x54,0xc1,0x93,0x40,
        0x17,0x8b,0x28,0x32,0xb6,0xee,0xc8,0x39,0x59,0xc2,0xf9,0x9e,0x81,0x03,0xc6,0x47,
        0xf8,0x64,0x73,0x9a,0xb5,0xf9,0x07,0xa2,0xdb,0xdb,0x2e,0xe9,0x0f,0xc7,0x9b,0x55,
        0x03,0x0b,0xb9,0x1f,0x72,0x7f,0x4f,0xab,0x04,0xa6,0x40,0x80,0xc8,0x67,0x8d,0xd7,
        0x30,0x89,0xa2,0x00,0xe4,0x02,0xcf,0x39,0x50,0x0f,0x9e,0xfe,0x66,0x48,0x5b,0x59,
        0x6e,0x59,0xb9,0x71,0xa5,0x25,0x00,0xfa,0x36,0x72,0x92,0x6e,0x4d,0xdd,0x57,0x08,
        0x75,0xe9,0x29,0x8d,0xe6,0x5c,0xc4,0x1d,0x13,0x18,0x53,0x22,0xab,0xda,0x21,0x30,
        0x83,0x05,0x44,0x98,0x22,0xb1,0xd7,0x07,0x0f,0xd7,0x9b,0x88,0xb1,0xc0,0x3a,0x41,
        0x4e,0x5b,0x59,0xbd,0x31,0x71,0xcc,0xbb,0x77,0x56,0xa6,0x9d,0xc5,0x77,0x3c,0xf2,
        0x7c,0xbc,0x7d,0xd6,0x31,0xdd,0xcf,0x3e,0x3e,0x41,0xad,0x45,0x25,0xfb,0xce,0xbd,
        0x1f,0x72,0x86,0x98,0x4d,0xde,0x8c,0xef,0xfb,0xd8,0x54,0x3c,0x7b,0x6c,0xa5,0x74,
        0x94,0x76,0xfb,0xf9,0x6f,0xd0,0xd9,0x8a,0xf4,0xf5,0x57,0x9a,0x5b,0x6a,0xb3,0x1b,
        0x51,0x02,0xb9,0x87,0xe5,0x7a,0x5b,0xb0,0x8e,0xac,0x36,0x3f,0x92,0x0f,0x78,0x75,
        0xb2,0x20,0x0c,0x86,0x64,0xe8,0x78,0xc8,0xf6,0x9f,0xf4,0x93,0x55,0xba,0x42,0x01,
        0x0b,0x0b,0xac,0xc6,0x8e,0xf3,0xec,0xd0,0xaf,0x3c,0xa8,0xea,0x96,0xc0,0x09,0x29,
        0xc9,0x30,0x50,0x17,0x53,0x52,0x72,0x83,0x6c,0x1d,0xca,0x08,0x8d,0xe6,0xec,0x1f,
        0xb0,0x27,0x36,0x5c,0xf8,0xdd,0xaf,0x77,0x23,0x41,0x53,0x2e,0xf6,0x62,0x1d,0xa3,
        0xdd,0xe0,0xd2,0xbf,0x21,0xe2,0x0c,0xea,0x3f,0x80,0xbd,0xa5,0x14,0x69,0xba,0x1a,
        0xf6,0x1f,0x9d,0x09,0xe7,0xca,0x02,0xde,0x94,0xf1,0x91,0x55,0x9d,0x09,0xb8,0x00,
        0x55,0x68,0x31,0x00,0xf7,0x7e,0xf3,0xd0,0x91,0xb5,0x43,0x86,0xd8,0x89,0xab,0x9d,
        0x93,0x2f,0x0f,0xf0,0x5b,0x06,0x63,0xdf,0x2f,0x9b,0xef,0xc3,0x28,0x1c,0x9a,0xfc,
        0x25,0xa9,0x13,0xc0,0xde,0x99,0xeb,0x92,0xaa,0x12,0x63,0x17,0x3a,0xdd,0x78,0x02,
        0x8e,0x51,0x43,0x98,0x39,0xef,0xcc,0xa0,0x04,0x8a,0xd6,0x9a,0x51,0x56,0xbf,0xc5,
};

static void test_mbedtls_aes_ctr_enc(void)
{
    mbedtls_aes_context aes_ctx;
    unsigned char dec_plain[512] = {0};
    unsigned int i = 0;
    int ret = 0;
    uint8_t iv[16] = {0};
    uint8_t strblk[16] = {0};
    size_t nc_off = 0;
    memset(strblk,0,sizeof strblk);

    mbedtls_aes_init(&aes_ctx);
    mbedtls_aes_setkey_enc(&aes_ctx, aes_test_ctr_key, 128);
    memcpy(iv, aes_test_ctr_iv, sizeof iv);
    mbedtls_aes_crypt_ctr(&aes_ctx,
                          sizeof(aes_test_ctr_enc),
                          &nc_off,
                          iv,
                          strblk,
                          aes_test_ctr_enc,
                          dec_plain);
    mbedtls_aes_free(&aes_ctx);
#if 0
    for (i = 0; i < sizeof(dec_plain); i ++) {
        if (i % 16 == 0) {
            printf("\n");
        }
        printf("0x%2x,", dec_plain[i]);
    }
    printf("            ");
#endif
    ret = memcmp(aes_test_ctr_dec, dec_plain, sizeof dec_plain);
    CU_ASSERT_NSTRING_EQUAL(aes_test_ctr_dec, dec_plain, sizeof dec_plain)
}

static void test_mbedtls_aes_ctr_dec(void)
{
    mbedtls_aes_context aes_ctx;
    unsigned char enc_plain[512] = {0};
    unsigned int i = 0;
    int ret = 0;
    uint8_t iv[16] = {0};
    uint8_t strblk[16] = {0};
    size_t nc_off = 0;
    memset(strblk,0,sizeof strblk);
    mbedtls_aes_init(&aes_ctx);
    mbedtls_aes_setkey_enc(&aes_ctx, aes_test_ctr_key, 128);
    memcpy(iv, aes_test_ctr_iv, sizeof iv);

    mbedtls_aes_crypt_ctr(&aes_ctx,
                          sizeof(aes_test_ctr_dec),
                          &nc_off,
                          iv,
                          strblk,
                          aes_test_ctr_dec,
                          enc_plain);
    mbedtls_aes_free(&aes_ctx);
#if 0
    for (i = 0; i < sizeof(dec_plain); i ++) {
        if (i % 16 == 0) {
            printf("\n");
        }
        printf("0x%2x,", dec_plain[i]);
    }
    printf("            ");
#endif
    ret = memcmp(aes_test_ctr_dec, enc_plain, sizeof enc_plain);
    CU_ASSERT_NSTRING_EQUAL(aes_test_ctr_enc, enc_plain, sizeof enc_plain)
}


static const unsigned char aes_test_ctr_enc_str[512] = {
        0x13,0x9e,0x26,0xaf,0xc5,0x72,0x44,0xbc,0x6d,0x78,0x50,0x66,0x2f,0x66,0x8f,0x8e,
        0x4f,0xa0,0x34,0x03,0x7c,0x72,0x20,0x46,0x12,0xbd,0x7b,0x74,0xbe,0xf7,0x38,0x11,
        0x9d,0xe6,0x03,0x8b,0x4f,0xcc,0x42,0x16,0xa7,0xd0,0x8d,0x9b,0x7d,0x9e,0x10,0x36,
        0x9d,0x38,0x35,0x76,0x31,0xa3,0x23,0x54,0x74,0x1e,0xc1,0x16,0xd3,0x18,0x59,0xfb,
        0xdf,0x2a,0x7b,0xe4,0x2b,0x0d,0xd3,0xa0,0xb2,0x0f,0x9a,0xe9,0x7e,0xc8,0x0e,0x1e,
        0x13,0xea,0x6a,0x20,0xb9,0x0f,0x68,0x06,0xe4,0xb7,0xad,0x7d,0xca,0xb1,0x83,0x10,
        0xa2,0x9e,0x9f,0xd8,0x39,0x47,0x8f,0x7a,0x8f,0x70,0x57,0xbd,0x90,0xef,0xec,0x5f,
        0xb4,0x1e,0x62,0xe8,0xd6,0x35,0xc5,0x87,0x52,0x27,0x94,0xcd,0xe4,0x53,0xeb,0xb5,
        0xa2,0xd9,0x28,0x61,0x34,0x43,0xab,0x5a,0xd9,0xc9,0x38,0x50,0xba,0x35,0x0c,0x4c,
        0x8c,0xd7,0xc7,0xaa,0x79,0x2f,0x0d,0x00,0x27,0x90,0x08,0x04,0x50,0xbe,0xd8,0x7b,
        0x92,0x08,0x9b,0xb7,0x6d,0xe1,0xc2,0x2e,0x13,0xce,0xbd,0xa3,0xd5,0x22,0x46,0xb9,
        0x27,0xee,0x57,0x28,0xe8,0x7a,0x27,0x2f,0x3c,0x2e,0xbe,0xd0,0xfa,0xd1,0xad,0x91,
        0xb4,0xb4,0x2c,0x43,0xce,0x45,0xc0,0xdb,0x73,0x44,0x65,0x57,0xb4,0x4c,0xda,0x4a,
        0xbb,0xc6,0x25,0x8c,0x5f,0x7a,0x24,0xd5,0xac,0xc4,0xc3,0x0a,0xcb,0x7d,0x7e,0x48,
        0x04,0x40,0xba,0x33,0x79,0xca,0x50,0x1d,0x4f,0xf5,0xbd,0x8e,0x4b,0xee,0xef,0xe6,
        0xcd,0x00,0xe7,0x3f,0xd9,0x65,0xd0,0xcc,0x60,0x27,0x80,0x7b,0xe3,0x7e,0x07,0x85,
        0x13,0x9e,0x26,0xaf,0xc5,0x72,0x44,0xbc,0x6d,0x78,0x50,0x66,0x2f,0x66,0x8f,0x8e,
        0x4f,0xa0,0x34,0x30,0x7c,0x72,0x20,0x46,0x12,0xbd,0x7b,0x74,0xbe,0xf7,0x38,0x11,
        0x9d,0xe6,0x30,0x8b,0x4f,0xcc,0x42,0x16,0xa7,0xd0,0x8d,0x9b,0x7d,0x9e,0x10,0x36,
        0x9d,0x38,0x35,0x76,0x31,0xa3,0x23,0x54,0x74,0x1e,0xc1,0x16,0xd3,0x18,0x59,0xfb,
        0xdf,0x2a,0x7b,0xe4,0x2b,0x0d,0xd3,0xa0,0xb2,0x0f,0x9a,0xe9,0x7e,0xc8,0x0e,0x1e,
        0x13,0xea,0x6a,0x20,0xb9,0x0f,0x68,0x06,0xe4,0xb7,0xad,0x7d,0xca,0xb1,0x83,0x10,
        0xa2,0x9e,0x9f,0xd8,0x39,0x47,0x8f,0x7a,0x8f,0x70,0x57,0xbd,0x90,0xef,0xec,0x5f,
        0xb4,0x1e,0x62,0xe8,0xd6,0x35,0xc5,0x87,0x52,0x27,0x94,0xcd,0xe4,0x53,0xeb,0xb5,
        0xa2,0xd9,0x28,0x61,0x34,0x43,0xab,0x5a,0xd9,0xc9,0x38,0x50,0xba,0x35,0x0c,0x4c,
        0x8c,0xd7,0xc7,0xaa,0x79,0x2f,0x0d,0x00,0x27,0x90,0x08,0x04,0x50,0xbe,0xd8,0x7b,
        0x92,0x08,0x9b,0xb7,0x6d,0xe1,0xc2,0x2e,0x13,0xce,0xbd,0xa3,0xd5,0x22,0x46,0xb9,
        0x27,0xee,0x57,0x28,0xe8,0x7a,0x27,0x2f,0x3c,0x2e,0xbe,0xd0,0xfa,0xd1,0xad,0x91,
        0xb4,0xb4,0x2c,0x43,0xce,0x45,0xc0,0xdb,0x73,0x44,0x65,0x57,0xb4,0x4c,0xda,0x4a,
        0xbb,0xc6,0x25,0x8c,0x5f,0x7a,0x24,0xd5,0xac,0xc4,0xc3,0x0a,0xcb,0x7d,0x7e,0x48,
        0x40,0x40,0xba,0x33,0x79,0xca,0x50,0x1d,0x4f,0xf5,0xbd,0x8e,0x4b,0xee,0xef,0xe6,
        0xcd,0x00,0xe7,0x3f,0xd9,0x65,0xd0,0xcc,0x60,0x27,0x80,0x7b,0xe3,0x7e,0x46,0x89
};

static const unsigned char aes_test_ctr_key_str[16] = {
        0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
        0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C,
};
static const unsigned char aes_test_ctr_iv_str[16] = {
        0x55, 0x5c, 0x82, 0x24, 0xe2, 0xc9, 0x58, 0x73,
        0x12, 0x08, 0x5b, 0xfb, 0x4e, 0xcb, 0x04, 0xb8,
};

static const unsigned char aes_test_ctr_strblk[16] = {
        0x8e,0x51,0x43,0x98,0x39,0xef,0xcc,0xa0,0x04,0x8a,0xd6,0x9a,0x51,0x56,0xbf,0xc5,
};

static const unsigned char aes_test_ctr_dec_str[512] = {
        0xb3,0x9a,0xac,0x79,0x5f,0x23,0x12,0x03,0xa8,0xf3,0x38,0x82,0x3f,0xb6,0x2b,0xb3,
        0xca,0x1e,0x58,0x4b,0xe3,0xae,0x3a,0xdc,0xfb,0xda,0xc2,0xe0,0xdb,0x02,0x8b,0xd2,
        0x1e,0xaf,0xb5,0xe5,0xf3,0x76,0x74,0x4f,0xaf,0x6a,0x42,0x40,0x12,0x07,0x92,0x95,
        0xd7,0xb2,0x93,0x43,0xae,0xb2,0xfb,0xd0,0x9f,0x39,0x74,0x18,0x43,0xa4,0x41,0x63,
        0x9e,0xe1,0xcc,0xd5,0x44,0xb8,0x1a,0xf7,0x0a,0x73,0xe0,0xd1,0x15,0x51,0x58,0xc5,
        0x99,0x09,0x08,0x9d,0x46,0xe5,0x8c,0x60,0xad,0xaf,0x7b,0x98,0x24,0x60,0x1b,0x18,
        0x99,0x7c,0x8a,0x10,0x8f,0x63,0xcb,0x7d,0x2e,0xba,0x5c,0x00,0x6f,0x22,0x1b,0x57,
        0x8a,0xb4,0x5d,0xc9,0x0e,0x11,0x71,0x04,0xb4,0x7b,0xd3,0x43,0xac,0xc8,0x1a,0x2c,
        0x80,0xbd,0x0f,0x51,0xfc,0x48,0xc3,0x89,0xb4,0x9c,0x23,0xb1,0x21,0xc8,0x51,0x23,
        0x06,0xb2,0x38,0xd0,0x70,0xdf,0x21,0x72,0x15,0x5e,0xeb,0xeb,0x50,0x18,0xbc,0x7a,
        0x7b,0xef,0x90,0xeb,0xdf,0xe5,0xbd,0x65,0x28,0x4b,0x3e,0x10,0x50,0xf9,0x49,0xb3,
        0x30,0xa4,0x5b,0x6c,0xd5,0x2e,0x06,0xaf,0xc2,0xf1,0x34,0xf4,0x48,0x8c,0x2e,0xb1,
        0x39,0x53,0xd9,0xd3,0xf7,0xb0,0xd6,0xed,0xb7,0xf3,0xda,0xc2,0xe8,0xf0,0xe0,0xc5,
        0xcb,0xb1,0xc7,0xa9,0x88,0x06,0x0f,0x82,0x31,0x4f,0x8c,0x8d,0x47,0xc6,0x06,0xa3,
        0xe8,0xbc,0x71,0x6e,0x8d,0x67,0x65,0x38,0x5e,0x9f,0xa4,0x8d,0x09,0x32,0x00,0xb6,
        0x2a,0x79,0x60,0x10,0x39,0x63,0xe3,0x74,0x8e,0x9f,0x69,0xb5,0x51,0x41,0x3e,0x91,
        0xc2,0xed,0x19,0x7c,0x9c,0x3a,0xe0,0x9a,0xd8,0xe8,0xcb,0x04,0x18,0x81,0x4c,0x1d,
        0xf4,0xc2,0x9b,0xfb,0x92,0xec,0x86,0xf3,0xdd,0xbc,0x80,0x19,0x33,0xba,0x3b,0xfd,
        0x60,0x83,0xdb,0x56,0xa6,0xb7,0xc2,0x12,0x44,0x31,0xd7,0xd6,0x20,0xe0,0x01,0xbb,
        0xb5,0xa1,0xa4,0x56,0xef,0xfb,0x46,0x8a,0xff,0x9c,0x8b,0xa5,0x3d,0x64,0x24,0x54,
        0x64,0xa5,0xbd,0x71,0x01,0xa5,0xa7,0x5c,0x3d,0x44,0xc6,0x69,0x63,0x8c,0xd3,0x14,
        0x39,0xac,0x90,0xed,0xca,0x2a,0xca,0xbb,0xe1,0xf5,0x45,0xae,0x6d,0xed,0xf6,0x23,
        0x14,0xf4,0x84,0x43,0x7b,0x1f,0x31,0x81,0xea,0x60,0xe9,0x2e,0xce,0xb2,0x43,0xa8,
        0x06,0x67,0x8d,0x4b,0xf8,0xf0,0x90,0x29,0x0c,0x98,0x81,0x03,0xca,0x0b,0x2d,0x9c,
        0xf5,0x24,0x33,0x5d,0x13,0x31,0x38,0xb8,0x45,0xa2,0xd1,0x28,0xcc,0x52,0x1d,0x95,
        0x55,0x62,0x13,0x58,0x21,0x18,0xde,0xe0,0x74,0xac,0xf8,0xf5,0xa6,0x3f,0x2a,0xd9,
        0xe5,0x0c,0x4a,0xec,0x47,0x47,0x1e,0xeb,0xcb,0x81,0x55,0xea,0xdd,0x6e,0x45,0x77,
        0xe3,0xc2,0x19,0x28,0xee,0xbb,0x6c,0xd3,0x9f,0xff,0x4f,0x1a,0xdb,0xde,0x1d,0xb4,
        0x45,0x1c,0xf3,0x6c,0x4b,0x22,0x18,0xce,0xe2,0xa5,0xb9,0x4a,0xf7,0x75,0xe1,0x79,
        0xb0,0x24,0xd4,0xaa,0x8e,0x16,0xe1,0xa4,0x7b,0xec,0x2a,0x20,0xb7,0x79,0x02,0x0f,
        0x4a,0xc3,0xe5,0x1f,0xb0,0x29,0x31,0xf9,0xfb,0x90,0x54,0x27,0xb8,0x49,0xbc,0x5d,
        0x42,0xe5,0x00,0xe1,0x40,0x14,0xe3,0x5b,0x84,0x64,0xd1,0xdf,0x44,0x9e,0xcc,0x95,
};

static void test_mbedtls_aes_ctr_enc_str(void)
{
    mbedtls_aes_context aes_ctx;
    unsigned char dec_plain[512] = {0};
    unsigned int i = 0;
    int ret = 0;
    uint8_t iv[16] = {0};
    uint8_t strblk[16] = {0};
    size_t nc_off = 7;

    mbedtls_aes_init(&aes_ctx);
    mbedtls_aes_setkey_enc(&aes_ctx, aes_test_ctr_key_str, 128);
    memcpy(iv, aes_test_ctr_iv_str, sizeof iv);
    memcpy(strblk, aes_test_ctr_strblk, sizeof strblk);
    mbedtls_aes_crypt_ctr(&aes_ctx,
                          sizeof(aes_test_ctr_enc_str),
                          &nc_off,
                          iv,
                          strblk,
                          aes_test_ctr_enc_str,
                          dec_plain);
    mbedtls_aes_free(&aes_ctx);
#if 0
    for (i = 0; i < sizeof(dec_plain); i ++) {
        if (i % 16 == 0) {
            printf("\n");
        }
        printf("0x%2x,", dec_plain[i]);
    }
    printf("            ");
#endif
    ret = memcmp(aes_test_ctr_dec, dec_plain, sizeof dec_plain);
    CU_ASSERT_NSTRING_EQUAL(aes_test_ctr_dec_str, dec_plain, sizeof dec_plain)
}

static void test_mbedtls_aes_ctr_dec_str(void)
{
    mbedtls_aes_context aes_ctx;
    unsigned char enc_plain[512] = {0};
    unsigned int i = 0;
    int ret = 0;
    uint8_t iv[16] = {0};
    uint8_t strblk[16] = {0};
    size_t nc_off = 7;
    memset(strblk,0,sizeof strblk);
    mbedtls_aes_init(&aes_ctx);
    mbedtls_aes_setkey_enc(&aes_ctx, aes_test_ctr_key_str, 128);
    memcpy(iv, aes_test_ctr_iv_str, sizeof iv);
    memcpy(strblk, aes_test_ctr_strblk, sizeof strblk);
    mbedtls_aes_crypt_ctr(&aes_ctx,
                          sizeof(aes_test_ctr_dec_str),
                          &nc_off,
                          iv,
                          strblk,
                          aes_test_ctr_dec_str,
                          enc_plain);
    mbedtls_aes_free(&aes_ctx);
#if 0
    for (i = 0; i < sizeof(dec_plain); i ++) {
        if (i % 16 == 0) {
            printf("\n");
        }
        printf("0x%2x,", dec_plain[i]);
    }
    printf("            ");
#endif
    ret = memcmp(aes_test_ctr_dec, enc_plain, sizeof enc_plain);
    CU_ASSERT_NSTRING_EQUAL(aes_test_ctr_enc_str, enc_plain, sizeof enc_plain)
}


static void test_mbedtls_hmac_384(void)
{
    int ret = 0, i = 0;
    unsigned char key[] = {1,5,8,8,9,5,6,204,5,4,8,0,0,0,0};
    unsigned char input[] = {1,5,8,8,9,5,6,204,5,4,8,0,0,0,0};
    unsigned char output[48] = {0};

    ret = mbedtls_hmac_sha384(key,
                              sizeof(key)/sizeof(key[0]),
                              input,
                              sizeof(input)/sizeof(input[0]),
                              output);
    for (i = 0; i < 48; i ++) {
        mbedtls_printf("%x", output[i]);
    }
    mbedtls_printf("\n");
    CU_ASSERT_EQUAL(ret, 0);
}

static CU_TestInfo test_sca_suite[] = {
        {"test mbedtls aes ecb enc", TEST_FUN(test_mbedtls_aes_ecb_enc)},
        {"test mbedtls aes ecb dec", TEST_FUN(test_mbedtls_aes_ecb_dec)},
        {"test mbedtls aes cbc enc", TEST_FUN(test_mbedtls_aes_cbc_enc)},
        {"test mbedtls aes cbc dec", TEST_FUN(test_mbedtls_aes_cbc_dec)},
        {"test mbedtls aes cbc enc 256", TEST_FUN(test_mbedtls_aes_cbc_enc_256)},
        {"test mbedtls aes cbc dec 256", TEST_FUN(test_mbedtls_aes_cbc_dec_256)},
        {"test mbedtls aes ctr enc", TEST_FUN(test_mbedtls_aes_ctr_enc)},
        {"test mbedtls aes ctr dec", TEST_FUN(test_mbedtls_aes_ctr_dec)},
        {"test mbedtls aes ctr-str enc", TEST_FUN(test_mbedtls_aes_ctr_enc_str)},
        {"test mbedtls aes ctr-str dec", TEST_FUN(test_mbedtls_aes_ctr_dec_str)},
        CU_TEST_INFO_NULL,
};

static CU_TestInfo test_hash_suite[] = {
        {"test mbedtls hmac", TEST_FUN(test_mbedtls_hmac_384)},
        CU_TEST_INFO_NULL,
};


static CU_SuiteInfo suites_list[] = {
  //{ "mbedtls test cmac",  suite_success_init, suite_success_clean, NULL, NULL, test_cmac_suite},

  { "mbedtls test sca",  suite_success_init, suite_success_clean, NULL, NULL, test_sca_suite},
  { "mbedtls test hash",  suite_success_init, suite_success_clean, NULL, NULL, test_hash_suite},
  CU_SUITE_INFO_NULL,
};


void add_mbedtls_testsuite(void)
{
  assert(NULL != CU_get_registry());
  assert(!CU_is_test_running());

	/* Register suites. */
	if (CU_register_suites(suites_list) != CUE_SUCCESS) {
		fprintf(stderr, "suite registration failed - %s\n",
			CU_get_error_msg());
		exit(EXIT_FAILURE);
	}

/* implementation without shortcut registration
  CU_pSuite pSuite;

  pSuite = CU_add_suite("suite_success_both", suite_success_init, suite_success_clean);
  CU_add_test(pSuite, "testSuccess1", testSuccess1);
  CU_add_test(pSuite, "testSuccess2", testSuccess2);
  CU_add_test(pSuite, "testSuccess3", testSuccess3);

  pSuite = CU_add_suite("suite_success_init", suite_success_init, NULL);
  CU_add_test(pSuite, "testSuccess1", testSuccess1);
  CU_add_test(pSuite, "testSuccess2", testSuccess2);
  CU_add_test(pSuite, "testSuccess3", testSuccess3);

  pSuite = CU_add_suite("suite_success_clean", NULL, suite_success_clean);
  CU_add_test(pSuite, "testSuccess1", testSuccess1);
  CU_add_test(pSuite, "testSuccess2", testSuccess2);
  CU_add_test(pSuite, "testSuccess3", testSuccess3);

  pSuite = CU_add_suite("test_failure", NULL, NULL);
  CU_add_test(pSuite, "testFailure1", testFailure1);
  CU_add_test(pSuite, "testFailure2", testFailure2);
  CU_add_test(pSuite, "testFailure3", testFailure3);

  / * tests should not run * /
  pSuite = CU_add_suite("suite_failure_both", suite_failure_init, suite_failure_clean);
  CU_add_test(pSuite, "testSuiteFailure1", testSuiteFailure1);
  CU_add_test(pSuite, "testSuiteFailure2", testSuiteFailure2);

  / * tests should not run * /
  pSuite = CU_add_suite("suite_failure_init", suite_failure_init, NULL);
  CU_add_test(pSuite, "testSuiteFailure1", testSuiteFailure1);
  CU_add_test(pSuite, "testSuiteFailure2", testSuiteFailure2);

  / * tests will run, suite counted as running, but suite tagged as a failure * /
  pSuite = CU_add_suite("suite_success_but_failure_clean", NULL, suite_failure_clean);
  CU_add_test(pSuite, "testSuiteFailure1", testSuiteFailure1);
  CU_add_test(pSuite, "testSuiteFailure2", testSuiteFailure2);

  pSuite = CU_add_suite("TestSimpleAssert", NULL, NULL);
  CU_add_test(pSuite, "testSimpleAssert", testSimpleAssert);
  CU_add_test(pSuite, "testFail", testFail);

  pSuite = CU_add_suite("TestBooleanAssert", NULL, NULL);
  CU_add_test(pSuite, "testAssertTrue", testAssertTrue);
  CU_add_test(pSuite, "testAssertFalse", testAssertFalse);

  pSuite = CU_add_suite("TestEqualityAssert", NULL, NULL);
  CU_add_test(pSuite, "testAssertEqual", testAssertEqual);
  CU_add_test(pSuite, "testAssertNotEqual", testAssertNotEqual);

  pSuite = CU_add_suite("TestPointerAssert", NULL, NULL);
  CU_add_test(pSuite, "testAssertPtrEqual", testAssertPtrEqual);
  CU_add_test(pSuite, "testAssertPtrNotEqual", testAssertPtrNotEqual);

  pSuite = CU_add_suite("TestNullnessAssert", NULL, NULL);
  CU_add_test(pSuite, "testAssertPtrNull", testAssertPtrNull);
  CU_add_test(pSuite, "testAssertPtrNotNull", testAssertPtrNotNull);

  pSuite = CU_add_suite("TestStringAssert", NULL, NULL);
  CU_add_test(pSuite, "testAssertStringEqual", testAssertStringEqual);
  CU_add_test(pSuite, "testAssertStringNotEqual", testAssertStringNotEqual);

  pSuite = CU_add_suite("TestNStringAssert", NULL, NULL);
  CU_add_test(pSuite, "testAssertNStringEqual", testAssertNStringEqual);
  CU_add_test(pSuite, "testAssertNStringNotEqual", testAssertNStringNotEqual);

  pSuite = CU_add_suite("TestDoubleAssert", NULL, NULL);
  CU_add_test(pSuite, "testAssertDoubleEqual", testAssertDoubleEqual);
  CU_add_test(pSuite, "testAssertDoubleNotEqual", testAssertDoubleNotEqual);

  pSuite = CU_add_suite("TestFatal", NULL, NULL);
  CU_add_test(pSuite, "testFatal", testFatal);
*/
}
